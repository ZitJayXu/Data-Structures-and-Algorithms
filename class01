01 有序数组中找到>=num最左的位置
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
//找到数组中>=key的最左侧数字
class Solution {
public:
    static void BSFindNearLeft(vector<int>& a, int key) {
        int L = 0, R = a.size() - 1; int index=-1;
        while (L<=R) {
            int mid = L + ((R - L) >> 1);
            if (a[mid] >= key) {
                R = mid - 1;
                index = mid;
            }
            else {
                L = mid + 1;
            }
        }
        cout<<index;//返回所在位置的小标
    }
};
//for test
int main(){
    vector<int>test{ 0,1,1,2,3,4,5,5,6,6,6,7,8,9 };
    Solution::BSFindNearLeft(test, 6);
    return 0;
    system("pause");
}
02 排序
#include<iostream>//时间复杂度为O(N^2)的排序
#include<vector>
using namespace std;
//冒泡排序
vector<int>& Bubblesort(vector<int>& a) {//函数中的容器参数以引用方式传入，不然会引发访问冲突
for (int i = a.size(); i > 0; i--) {
		for (int j = 0; j+1 < i; j++) {
			if (a[j] > a[j + 1]) {
				swap(a[j], a[j + 1]);
			}
		}
	}
	return a;
}
//选择排序
vector<int>& Choosensort(vector<int>& a) {
	for (int i = 0; i < a.size(); i++) {
		int minnum = i;
		for (int j = i + 1; j < a.size() - 1; j++) {
			if (a[j] < a[minnum]) {
				minnum = j; //找到最小的索引
			}
		}
		int temp = a[minnum];
		a[minnum] =a[i];
		a[i]=temp;
	}
	return a;
}
//插入排序
vector<int>&insertsort(vector<int>& a)
{
	int n = a.size();
	for (int j = 1; j < n; j++) {
		int key = a[j];
		int i = j - 1;
		while (i >= 0 && key < a[i]) {
			a[i + 1] = a[i]; i--;
		}
		a[i+1] = key;
	}
	return a;
}

//打印
void Printit(vector<int>b)
{
	for (int j = 0; j < b.size(); j++) {
		cout << b[j] << endl;
	}
}
int main()//测试
{
	vector<int>test{ 6,4,5,3,2,9 };
	Printit(insertsort(test));
}
